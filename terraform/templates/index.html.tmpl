<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Atlas RS Greeting Demo (${cluster_name})</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 2rem; max-width: 760px; }
    h1 { font-size: 1.4rem; }
    .latest { padding: 1rem; border: 1px solid #ccc; border-radius: 6px; background: #fafafa; min-height: 3rem; }

    .controls {  
        display: flex;  
        justify-content: space-between;  
        align-items: center;  
        margin-top: 1rem;  
    }

    label { display:block; margin-top:1rem; font-weight:600; }
    input[type=number]{ width:6rem; }
    button { margin-top:1rem; padding:.6rem 1rem; border:1px solid #2b5; background:#2d7; color:#fff; border-radius:4px; cursor:pointer; }
    button:hover { background:#268d46; }
    code { background:#eee; padding:2px 4px; border-radius:3px; }
    footer { margin-top:2rem; font-size:.75rem; color:#666; }
    .warn { color:#b00; font-weight:600; }
  </style>
</head>
<body>
  <h1>Latest Greeting (MongoDB Atlas Replica Set)</h1>
  <p>This regional static site polls a replica set member based on the configured readPreference (See th Console Output) via GCP Cloud Functions (v2) using the MongoDB Node.js driver.</p>

  <div class="latest" id="latestBox">Loading...</div>

  <!--<table><tr>
  <td><label>Refresh Interval (ms): <input id="intervalInput" type="number" min="20" max="10000" step="10" value="${refresh_default_ms}" /></label></td>
  <td><label>Read Preference: <input id="readPreference" type="number" min="20" max="10000" step="10" value="${readPreference}" /></label></td>
  </tr></table>-->

  <div class="controls">  
    <label>Refresh Interval (ms):  
        <input id="intervalInput" type="number" min="20" max="10000" step="10" value="${refresh_default_ms}">  
    </label>  
    
    <label>Read Preference:  
    <select id="readPreference">  
      <option value="primary" selected>primary</option>  
      <option value="primaryPreferred">primaryPreferred</option>  
      <option value="secondary">secondary</option>  
      <option value="secondaryPreferred">secondaryPreferred</option>  
      <option value="nearest">nearest</option>  
    </select>  
  </label>   
  </div> 

  <button id="recordBtn">Record Greeting</button>

  <p id="status"></p>

  <noscript><p class="warn">JavaScript required.</p></noscript>

  <script>
  const DB = "test";
  const COLL = "test"; // collection name
  const latestBox = document.getElementById('latestBox');
  const recordBtn = document.getElementById('recordBtn');
  const intervalInput = document.getElementById('intervalInput');
  const statusEl = document.getElementById('status');

  // API base: hardcoded to the regional function URL
  const API_BASE = "${api_base}";
  const FLAG = API_BASE.includes('-demo-us-') ? 'ðŸ‡ºðŸ‡¸' : 'ðŸ‡¦ðŸ‡º';
  const CLIENT_FETCH_TIMEOUT_MS = 4500;
  let latestFetchInFlight = false;

  function describeError(err) {
    if (!err) return 'Unknown error';
    if (err.name === 'AbortError') {
      return 'Browser cancelled request (client timeout)';
    }
    const msg = (err && err.message) ? err.message : String(err);
    if (/failed to fetch/i.test(msg) || /networkerror/i.test(msg)) {
      return 'Request failed before the Cloud Function responded (timeout or CORS)';
    }
    if (/upstream timeout/i.test(msg)) {
      return 'Cloud Function timed out talking to MongoDB';
    }
    return msg;
  }

  async function fetchLatest(){
    if (latestFetchInFlight) {
      return;
    }
    latestFetchInFlight = true;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), CLIENT_FETCH_TIMEOUT_MS);
    try {
      const t0 = performance.now();
      const rp = document.getElementById('readPreference')
      const res = await fetch(API_BASE + '/latest?rp=' + rp, {
        signal: controller.signal,
        cache: 'no-store',
      });
      if (res.status === 504) {
        const text = (await res.text()).slice(0, 200);
        const detail = /upstream timeout/i.test(text)
          ? 'Cloud Function timed out talking to MongoDB'
          : 'Request hit a gateway timeout';
        const message = 'Latest fetch timed out: ' + detail;
        latestBox.textContent = message;
        statusEl.textContent = message;
        return;
      }
      if(!res.ok){
        const text = await res.text();
        throw new Error('HTTP ' + res.status + ': ' + text.slice(0,120));
      }
      const json = await res.json();
      const clientMs = Math.round(performance.now() - t0);
      if(json && json.latest) {
        const d = json.latest;
        latestBox.textContent = ((d.timestamp||'') + ' - ' + (d.message||''));
      } else {
        latestBox.textContent = 'No greetings yet';
      }
      try {
        console.log(new Date().toLocaleString(), `: $${FLAG} [/latest] dbMs=$${json.dbMs ?? 'n/a'} clientMs=$${clientMs}ms  readPreference=$${json.readPreference||'n/a'} `);
      } catch(_) {}
    } catch(e){
      const detail = describeError(e);
      latestBox.textContent = 'Error fetching latest: ' + detail;
      statusEl.textContent = 'Latest fetch failed: ' + detail;
    } finally {
      clearTimeout(timeoutId);
      latestFetchInFlight = false;
    }
  }

  async function insertGreeting(){
    const greetings = ['Hello','Hi','G\u2019day','Hola','Bonjour','Ciao','Kia Ora','Namaste'];
    const message = greetings[Math.floor(Math.random()*greetings.length)] + ' from ' + (Intl.DateTimeFormat().resolvedOptions().timeZone || 'local');
    try {
      statusEl.textContent = 'Recording...';
      const t0 = performance.now();
      const res = await fetch(API_BASE + '/greet', { method:'POST' });
      if(!res.ok){
        const text = await res.text();
        throw new Error('HTTP ' + res.status + ': ' + text.slice(0,120));
      }
      const json = await res.json();
      const clientMs = Math.round(performance.now() - t0);
      if(json.insertedId){
        statusEl.textContent = 'Inserted ' + json.insertedId;
        try { console.log(new Date().toLocaleString(), `: $${FLAG} [/greet ] dbMs=$${json.dbMs ?? 'n/a'} clientMs=$${clientMs}ms  insertedId=$${json.insertedId} `); } catch(_) {}
        fetchLatest();
      } else {
        statusEl.textContent = 'Insert error';
      }
    } catch(e){
      statusEl.textContent = 'Insert failed: ' + describeError(e);
    }
  }

  recordBtn.addEventListener('click', insertGreeting);

  let timer = null;
  function schedule(){
    if(timer) clearInterval(timer);
    const ms = Math.min(10000, Math.max(20, parseInt(intervalInput.value,10) || ${refresh_default_ms}));
    timer = setInterval(fetchLatest, ms);
  }
  intervalInput.addEventListener('change', schedule);

  // Start only if API_BASE looks valid; otherwise instruct user
  schedule();
  fetchLatest();
  </script>
  <footer>Demo only. Using API base: <code>${api_base}</code>.</footer>
</body>
</html>